// Three.js setup
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Cannon.js setup
const world = new CANNON.World();
world.gravity.set(0, -9.82, 0); // Gravity in negative y-direction
world.broadphase = new CANNON.NaiveBroadphase();

// **Ground Plane**
// Visual representation in Three.js
const groundGeometry = new THREE.PlaneGeometry(100, 100);
const groundMaterial = new THREE.MeshPhongMaterial({ color: 0xaaaaaa });
const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
groundMesh.rotation.x = -Math.PI / 2; // Rotate to lie flat
scene.add(groundMesh);

// Physics representation in Cannon.js
const groundShape = new CANNON.Plane();
const groundBody = new CANNON.Body({ mass: 0 }); // Static body (mass = 0)
groundBody.addShape(groundShape);
groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0); // Align with Three.js plane
world.addBody(groundBody);

// **Bike Chassis**
// Physics body in Cannon.js
const chassisShape = new CANNON.Box(new CANNON.Vec3(1, 0.5, 2)); // Half-extents: 2x1x4
const chassisBody = new CANNON.Body({ mass: 150 }); // Dynamic body with mass
chassisBody.addShape(chassisShape);
chassisBody.position.set(0, 5, 0); // Start 5 units above ground
world.addBody(chassisBody);

// **Vehicle Setup**
const vehicle = new CANNON.RaycastVehicle({
  chassisBody: chassisBody,
});

// Wheel options (shared properties)
const wheelOptions = {
  radius: 0.5,
  directionLocal: new CANNON.Vec3(0, -1, 0), // Downward direction for raycasting
  suspensionStiffness: 30,
  suspensionRestLength: 0.3,
  frictionSlip: 5,
  dampingRelaxation: 2.3,
  dampingCompression: 4.4,
  maxSuspensionForce: 100000,
  rollInfluence: 0.01,
  axleLocal: new CANNON.Vec3(1, 0, 0), // Axle along x-axis (lateral)
  chassisConnectionPointLocal: new CANNON.Vec3(),
  maxSuspensionTravel: 0.3,
  customSlidingRotationalSpeed: -30,
  useCustomSlidingRotationalSpeed: true,
};

// Front wheel
wheelOptions.chassisConnectionPointLocal.set(0, 0, 1); // Front of chassis
vehicle.addWheel(wheelOptions);

// Rear wheel
wheelOptions.chassisConnectionPointLocal.set(0, 0, -1); // Rear of chassis
vehicle.addWheel(wheelOptions);

vehicle.addToWorld(world);

// **Bike Visuals**
// Chassis mesh in Three.js
const chassisGeometry = new THREE.BoxGeometry(2, 1, 4); // Full dimensions
const chassisMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 }); // Red color
const chassisMesh = new THREE.Mesh(chassisGeometry, chassisMaterial);
scene.add(chassisMesh);

// Wheel meshes
const wheelMeshes = [];
vehicle.wheelInfos.forEach(() => {
  const wheelGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.3, 32); // Radius 0.5, width 0.3
  const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 }); // Black color
  const wheelMesh = new THREE.Mesh(wheelGeometry, wheelMaterial);
  wheelMesh.rotation.z = Math.PI / 2; // Align cylinder with x-axis (axle)
  scene.add(wheelMesh);
  wheelMeshes.push(wheelMesh);
});

// **First-Person Camera**
chassisMesh.add(camera); // Attach camera to chassis for first-person view
camera.position.set(0, 1, 1.5); // Position above and near front of bike

// **Lighting**
const ambientLight = new THREE.AmbientLight(0x404040); // Soft ambient light
scene.add(ambientLight);
const directionalLight = new THREE.DirectionalLight(0xffffff, 1); // White directional light
directionalLight.position.set(10, 10, 10); // Positioned above and to the side
scene.add(directionalLight);

// **Track Element: Ramp**
// Physics body in Cannon.js
const rampShape = new CANNON.Box(new CANNON.Vec3(5, 0.5, 5)); // Half-extents: 10x1x10
const rampBody = new CANNON.Body({ mass: 0 }); // Static
rampBody.addShape(rampShape);
rampBody.position.set(10, 0, 0); // Positioned to the right of start
rampBody.quaternion.setFromEuler(0, 0, Math.PI / 6); // Tilted 30 degrees
world.addBody(rampBody);

// Visual mesh in Three.js
const rampGeometry = new THREE.BoxGeometry(10, 1, 10); // Full dimensions
const rampMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00 }); // Green color
const rampMesh = new THREE.Mesh(rampGeometry, rampMaterial);
rampMesh.position.copy(rampBody.position);
rampMesh.quaternion.copy(rampBody.quaternion);
scene.add(rampMesh);

// **Controls**
const keys = {
  ArrowUp: false,
  ArrowDown: false,
  ArrowLeft: false,
  ArrowRight: false,
};

// Event listeners for keyboard input
document.addEventListener('keydown', (event) => {
  if (event.key in keys) {
    keys[event.key] = true;
  }
});

document.addEventListener('keyup', (event) => {
  if (event.key in keys) {
    keys[event.key] = false;
  }
});

// Control parameters
const maxForce = 1000; // Maximum engine force
const maxSteerVal = 0.5; // Maximum steering angle

// Update vehicle based on input
function updateVehicle() {
  let engineForce = 0;
  let steering = 0;

  if (keys.ArrowUp) {
    engineForce = maxForce; // Accelerate forward
  } else if (keys.ArrowDown) {
    engineForce = -maxForce / 2; // Reverse (half force)
  }

  if (keys.ArrowLeft) {
    steering = maxSteerVal; // Steer left
  } else if (keys.ArrowRight) {
    steering = -maxSteerVal; // Steer right
  }

  vehicle.applyEngineForce(engineForce, 1); // Apply force to rear wheel (index 1)
  vehicle.setSteeringValue(steering, 0); // Steer front wheel (index 0)
}

// Update wheel positions and rotations
function updateWheelMeshes() {
  vehicle.wheelInfos.forEach((wheel, index) => {
    const transform = wheel.worldTransform;
    wheelMeshes[index].position.copy(transform.position);
    wheelMeshes[index].quaternion.copy(transform.quaternion);
  });
}

// **Animation Loop**
function animate() {
  requestAnimationFrame(animate);

  // Step the physics world
  world.step(1 / 60); // Fixed time step of 1/60 seconds

  // Update game state
  updateVehicle();
  updateWheelMeshes();

  // Sync chassis mesh with physics body
  chassisMesh.position.copy(chassisBody.position);
  chassisMesh.quaternion.copy(chassisBody.quaternion);

  // Render the scene
  renderer.render(scene, camera);
}
animate();

// **Window Resize Handling**
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
